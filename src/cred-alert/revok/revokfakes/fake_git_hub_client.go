// This file was generated by counterfeiter
package revokfakes

import (
	"cred-alert/revok"
	"sync"

	"code.cloudfoundry.org/lager"
)

type FakeGitHubClient struct {
	ListRepositoriesStub        func(lager.Logger) ([]revok.GitHubRepository, error)
	listRepositoriesMutex       sync.RWMutex
	listRepositoriesArgsForCall []struct {
		arg1 lager.Logger
	}
	listRepositoriesReturns struct {
		result1 []revok.GitHubRepository
		result2 error
	}
	RemainingRequestsStub        func(lager.Logger) (int, error)
	remainingRequestsMutex       sync.RWMutex
	remainingRequestsArgsForCall []struct {
		arg1 lager.Logger
	}
	remainingRequestsReturns struct {
		result1 int
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeGitHubClient) ListRepositories(arg1 lager.Logger) ([]revok.GitHubRepository, error) {
	fake.listRepositoriesMutex.Lock()
	fake.listRepositoriesArgsForCall = append(fake.listRepositoriesArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.recordInvocation("ListRepositories", []interface{}{arg1})
	fake.listRepositoriesMutex.Unlock()
	if fake.ListRepositoriesStub != nil {
		return fake.ListRepositoriesStub(arg1)
	} else {
		return fake.listRepositoriesReturns.result1, fake.listRepositoriesReturns.result2
	}
}

func (fake *FakeGitHubClient) ListRepositoriesCallCount() int {
	fake.listRepositoriesMutex.RLock()
	defer fake.listRepositoriesMutex.RUnlock()
	return len(fake.listRepositoriesArgsForCall)
}

func (fake *FakeGitHubClient) ListRepositoriesArgsForCall(i int) lager.Logger {
	fake.listRepositoriesMutex.RLock()
	defer fake.listRepositoriesMutex.RUnlock()
	return fake.listRepositoriesArgsForCall[i].arg1
}

func (fake *FakeGitHubClient) ListRepositoriesReturns(result1 []revok.GitHubRepository, result2 error) {
	fake.ListRepositoriesStub = nil
	fake.listRepositoriesReturns = struct {
		result1 []revok.GitHubRepository
		result2 error
	}{result1, result2}
}

func (fake *FakeGitHubClient) RemainingRequests(arg1 lager.Logger) (int, error) {
	fake.remainingRequestsMutex.Lock()
	fake.remainingRequestsArgsForCall = append(fake.remainingRequestsArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.recordInvocation("RemainingRequests", []interface{}{arg1})
	fake.remainingRequestsMutex.Unlock()
	if fake.RemainingRequestsStub != nil {
		return fake.RemainingRequestsStub(arg1)
	} else {
		return fake.remainingRequestsReturns.result1, fake.remainingRequestsReturns.result2
	}
}

func (fake *FakeGitHubClient) RemainingRequestsCallCount() int {
	fake.remainingRequestsMutex.RLock()
	defer fake.remainingRequestsMutex.RUnlock()
	return len(fake.remainingRequestsArgsForCall)
}

func (fake *FakeGitHubClient) RemainingRequestsArgsForCall(i int) lager.Logger {
	fake.remainingRequestsMutex.RLock()
	defer fake.remainingRequestsMutex.RUnlock()
	return fake.remainingRequestsArgsForCall[i].arg1
}

func (fake *FakeGitHubClient) RemainingRequestsReturns(result1 int, result2 error) {
	fake.RemainingRequestsStub = nil
	fake.remainingRequestsReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeGitHubClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.listRepositoriesMutex.RLock()
	defer fake.listRepositoriesMutex.RUnlock()
	fake.remainingRequestsMutex.RLock()
	defer fake.remainingRequestsMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeGitHubClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ revok.GitHubClient = new(FakeGitHubClient)
