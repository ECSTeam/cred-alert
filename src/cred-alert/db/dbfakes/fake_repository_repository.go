// This file was generated by counterfeiter
package dbfakes

import (
	"cred-alert/db"
	"sync"

	"code.cloudfoundry.org/lager"
)

type FakeRepositoryRepository struct {
	CreateStub        func(*db.Repository) error
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 *db.Repository
	}
	createReturns struct {
		result1 error
	}
	createReturnsOnCall map[int]struct {
		result1 error
	}
	FindStub        func(owner string, name string) (db.Repository, bool, error)
	findMutex       sync.RWMutex
	findArgsForCall []struct {
		owner string
		name  string
	}
	findReturns struct {
		result1 db.Repository
		result2 bool
		result3 error
	}
	findReturnsOnCall map[int]struct {
		result1 db.Repository
		result2 bool
		result3 error
	}
	MustFindStub        func(owner string, name string) (db.Repository, error)
	mustFindMutex       sync.RWMutex
	mustFindArgsForCall []struct {
		owner string
		name  string
	}
	mustFindReturns struct {
		result1 db.Repository
		result2 error
	}
	mustFindReturnsOnCall map[int]struct {
		result1 db.Repository
		result2 error
	}
	AllStub        func() ([]db.Repository, error)
	allMutex       sync.RWMutex
	allArgsForCall []struct{}
	allReturns     struct {
		result1 []db.Repository
		result2 error
	}
	allReturnsOnCall map[int]struct {
		result1 []db.Repository
		result2 error
	}
	ActiveStub        func() ([]db.Repository, error)
	activeMutex       sync.RWMutex
	activeArgsForCall []struct{}
	activeReturns     struct {
		result1 []db.Repository
		result2 error
	}
	activeReturnsOnCall map[int]struct {
		result1 []db.Repository
		result2 error
	}
	AllForOrganizationStub        func(string) ([]db.Repository, error)
	allForOrganizationMutex       sync.RWMutex
	allForOrganizationArgsForCall []struct {
		arg1 string
	}
	allForOrganizationReturns struct {
		result1 []db.Repository
		result2 error
	}
	allForOrganizationReturnsOnCall map[int]struct {
		result1 []db.Repository
		result2 error
	}
	NotScannedWithVersionStub        func(int) ([]db.Repository, error)
	notScannedWithVersionMutex       sync.RWMutex
	notScannedWithVersionArgsForCall []struct {
		arg1 int
	}
	notScannedWithVersionReturns struct {
		result1 []db.Repository
		result2 error
	}
	notScannedWithVersionReturnsOnCall map[int]struct {
		result1 []db.Repository
		result2 error
	}
	MarkAsClonedStub        func(string, string, string) error
	markAsClonedMutex       sync.RWMutex
	markAsClonedArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	markAsClonedReturns struct {
		result1 error
	}
	markAsClonedReturnsOnCall map[int]struct {
		result1 error
	}
	ReenableStub        func(string, string) error
	reenableMutex       sync.RWMutex
	reenableArgsForCall []struct {
		arg1 string
		arg2 string
	}
	reenableReturns struct {
		result1 error
	}
	reenableReturnsOnCall map[int]struct {
		result1 error
	}
	RegisterFailedFetchStub        func(lager.Logger, *db.Repository) error
	registerFailedFetchMutex       sync.RWMutex
	registerFailedFetchArgsForCall []struct {
		arg1 lager.Logger
		arg2 *db.Repository
	}
	registerFailedFetchReturns struct {
		result1 error
	}
	registerFailedFetchReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRepositoryRepository) Create(arg1 *db.Repository) error {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 *db.Repository
	}{arg1})
	fake.recordInvocation("Create", []interface{}{arg1})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.createReturns.result1
}

func (fake *FakeRepositoryRepository) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeRepositoryRepository) CreateArgsForCall(i int) *db.Repository {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return fake.createArgsForCall[i].arg1
}

func (fake *FakeRepositoryRepository) CreateReturns(result1 error) {
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepositoryRepository) CreateReturnsOnCall(i int, result1 error) {
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepositoryRepository) Find(owner string, name string) (db.Repository, bool, error) {
	fake.findMutex.Lock()
	ret, specificReturn := fake.findReturnsOnCall[len(fake.findArgsForCall)]
	fake.findArgsForCall = append(fake.findArgsForCall, struct {
		owner string
		name  string
	}{owner, name})
	fake.recordInvocation("Find", []interface{}{owner, name})
	fake.findMutex.Unlock()
	if fake.FindStub != nil {
		return fake.FindStub(owner, name)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.findReturns.result1, fake.findReturns.result2, fake.findReturns.result3
}

func (fake *FakeRepositoryRepository) FindCallCount() int {
	fake.findMutex.RLock()
	defer fake.findMutex.RUnlock()
	return len(fake.findArgsForCall)
}

func (fake *FakeRepositoryRepository) FindArgsForCall(i int) (string, string) {
	fake.findMutex.RLock()
	defer fake.findMutex.RUnlock()
	return fake.findArgsForCall[i].owner, fake.findArgsForCall[i].name
}

func (fake *FakeRepositoryRepository) FindReturns(result1 db.Repository, result2 bool, result3 error) {
	fake.FindStub = nil
	fake.findReturns = struct {
		result1 db.Repository
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeRepositoryRepository) FindReturnsOnCall(i int, result1 db.Repository, result2 bool, result3 error) {
	fake.FindStub = nil
	if fake.findReturnsOnCall == nil {
		fake.findReturnsOnCall = make(map[int]struct {
			result1 db.Repository
			result2 bool
			result3 error
		})
	}
	fake.findReturnsOnCall[i] = struct {
		result1 db.Repository
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeRepositoryRepository) MustFind(owner string, name string) (db.Repository, error) {
	fake.mustFindMutex.Lock()
	ret, specificReturn := fake.mustFindReturnsOnCall[len(fake.mustFindArgsForCall)]
	fake.mustFindArgsForCall = append(fake.mustFindArgsForCall, struct {
		owner string
		name  string
	}{owner, name})
	fake.recordInvocation("MustFind", []interface{}{owner, name})
	fake.mustFindMutex.Unlock()
	if fake.MustFindStub != nil {
		return fake.MustFindStub(owner, name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.mustFindReturns.result1, fake.mustFindReturns.result2
}

func (fake *FakeRepositoryRepository) MustFindCallCount() int {
	fake.mustFindMutex.RLock()
	defer fake.mustFindMutex.RUnlock()
	return len(fake.mustFindArgsForCall)
}

func (fake *FakeRepositoryRepository) MustFindArgsForCall(i int) (string, string) {
	fake.mustFindMutex.RLock()
	defer fake.mustFindMutex.RUnlock()
	return fake.mustFindArgsForCall[i].owner, fake.mustFindArgsForCall[i].name
}

func (fake *FakeRepositoryRepository) MustFindReturns(result1 db.Repository, result2 error) {
	fake.MustFindStub = nil
	fake.mustFindReturns = struct {
		result1 db.Repository
		result2 error
	}{result1, result2}
}

func (fake *FakeRepositoryRepository) MustFindReturnsOnCall(i int, result1 db.Repository, result2 error) {
	fake.MustFindStub = nil
	if fake.mustFindReturnsOnCall == nil {
		fake.mustFindReturnsOnCall = make(map[int]struct {
			result1 db.Repository
			result2 error
		})
	}
	fake.mustFindReturnsOnCall[i] = struct {
		result1 db.Repository
		result2 error
	}{result1, result2}
}

func (fake *FakeRepositoryRepository) All() ([]db.Repository, error) {
	fake.allMutex.Lock()
	ret, specificReturn := fake.allReturnsOnCall[len(fake.allArgsForCall)]
	fake.allArgsForCall = append(fake.allArgsForCall, struct{}{})
	fake.recordInvocation("All", []interface{}{})
	fake.allMutex.Unlock()
	if fake.AllStub != nil {
		return fake.AllStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.allReturns.result1, fake.allReturns.result2
}

func (fake *FakeRepositoryRepository) AllCallCount() int {
	fake.allMutex.RLock()
	defer fake.allMutex.RUnlock()
	return len(fake.allArgsForCall)
}

func (fake *FakeRepositoryRepository) AllReturns(result1 []db.Repository, result2 error) {
	fake.AllStub = nil
	fake.allReturns = struct {
		result1 []db.Repository
		result2 error
	}{result1, result2}
}

func (fake *FakeRepositoryRepository) AllReturnsOnCall(i int, result1 []db.Repository, result2 error) {
	fake.AllStub = nil
	if fake.allReturnsOnCall == nil {
		fake.allReturnsOnCall = make(map[int]struct {
			result1 []db.Repository
			result2 error
		})
	}
	fake.allReturnsOnCall[i] = struct {
		result1 []db.Repository
		result2 error
	}{result1, result2}
}

func (fake *FakeRepositoryRepository) Active() ([]db.Repository, error) {
	fake.activeMutex.Lock()
	ret, specificReturn := fake.activeReturnsOnCall[len(fake.activeArgsForCall)]
	fake.activeArgsForCall = append(fake.activeArgsForCall, struct{}{})
	fake.recordInvocation("Active", []interface{}{})
	fake.activeMutex.Unlock()
	if fake.ActiveStub != nil {
		return fake.ActiveStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.activeReturns.result1, fake.activeReturns.result2
}

func (fake *FakeRepositoryRepository) ActiveCallCount() int {
	fake.activeMutex.RLock()
	defer fake.activeMutex.RUnlock()
	return len(fake.activeArgsForCall)
}

func (fake *FakeRepositoryRepository) ActiveReturns(result1 []db.Repository, result2 error) {
	fake.ActiveStub = nil
	fake.activeReturns = struct {
		result1 []db.Repository
		result2 error
	}{result1, result2}
}

func (fake *FakeRepositoryRepository) ActiveReturnsOnCall(i int, result1 []db.Repository, result2 error) {
	fake.ActiveStub = nil
	if fake.activeReturnsOnCall == nil {
		fake.activeReturnsOnCall = make(map[int]struct {
			result1 []db.Repository
			result2 error
		})
	}
	fake.activeReturnsOnCall[i] = struct {
		result1 []db.Repository
		result2 error
	}{result1, result2}
}

func (fake *FakeRepositoryRepository) AllForOrganization(arg1 string) ([]db.Repository, error) {
	fake.allForOrganizationMutex.Lock()
	ret, specificReturn := fake.allForOrganizationReturnsOnCall[len(fake.allForOrganizationArgsForCall)]
	fake.allForOrganizationArgsForCall = append(fake.allForOrganizationArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("AllForOrganization", []interface{}{arg1})
	fake.allForOrganizationMutex.Unlock()
	if fake.AllForOrganizationStub != nil {
		return fake.AllForOrganizationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.allForOrganizationReturns.result1, fake.allForOrganizationReturns.result2
}

func (fake *FakeRepositoryRepository) AllForOrganizationCallCount() int {
	fake.allForOrganizationMutex.RLock()
	defer fake.allForOrganizationMutex.RUnlock()
	return len(fake.allForOrganizationArgsForCall)
}

func (fake *FakeRepositoryRepository) AllForOrganizationArgsForCall(i int) string {
	fake.allForOrganizationMutex.RLock()
	defer fake.allForOrganizationMutex.RUnlock()
	return fake.allForOrganizationArgsForCall[i].arg1
}

func (fake *FakeRepositoryRepository) AllForOrganizationReturns(result1 []db.Repository, result2 error) {
	fake.AllForOrganizationStub = nil
	fake.allForOrganizationReturns = struct {
		result1 []db.Repository
		result2 error
	}{result1, result2}
}

func (fake *FakeRepositoryRepository) AllForOrganizationReturnsOnCall(i int, result1 []db.Repository, result2 error) {
	fake.AllForOrganizationStub = nil
	if fake.allForOrganizationReturnsOnCall == nil {
		fake.allForOrganizationReturnsOnCall = make(map[int]struct {
			result1 []db.Repository
			result2 error
		})
	}
	fake.allForOrganizationReturnsOnCall[i] = struct {
		result1 []db.Repository
		result2 error
	}{result1, result2}
}

func (fake *FakeRepositoryRepository) NotScannedWithVersion(arg1 int) ([]db.Repository, error) {
	fake.notScannedWithVersionMutex.Lock()
	ret, specificReturn := fake.notScannedWithVersionReturnsOnCall[len(fake.notScannedWithVersionArgsForCall)]
	fake.notScannedWithVersionArgsForCall = append(fake.notScannedWithVersionArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("NotScannedWithVersion", []interface{}{arg1})
	fake.notScannedWithVersionMutex.Unlock()
	if fake.NotScannedWithVersionStub != nil {
		return fake.NotScannedWithVersionStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.notScannedWithVersionReturns.result1, fake.notScannedWithVersionReturns.result2
}

func (fake *FakeRepositoryRepository) NotScannedWithVersionCallCount() int {
	fake.notScannedWithVersionMutex.RLock()
	defer fake.notScannedWithVersionMutex.RUnlock()
	return len(fake.notScannedWithVersionArgsForCall)
}

func (fake *FakeRepositoryRepository) NotScannedWithVersionArgsForCall(i int) int {
	fake.notScannedWithVersionMutex.RLock()
	defer fake.notScannedWithVersionMutex.RUnlock()
	return fake.notScannedWithVersionArgsForCall[i].arg1
}

func (fake *FakeRepositoryRepository) NotScannedWithVersionReturns(result1 []db.Repository, result2 error) {
	fake.NotScannedWithVersionStub = nil
	fake.notScannedWithVersionReturns = struct {
		result1 []db.Repository
		result2 error
	}{result1, result2}
}

func (fake *FakeRepositoryRepository) NotScannedWithVersionReturnsOnCall(i int, result1 []db.Repository, result2 error) {
	fake.NotScannedWithVersionStub = nil
	if fake.notScannedWithVersionReturnsOnCall == nil {
		fake.notScannedWithVersionReturnsOnCall = make(map[int]struct {
			result1 []db.Repository
			result2 error
		})
	}
	fake.notScannedWithVersionReturnsOnCall[i] = struct {
		result1 []db.Repository
		result2 error
	}{result1, result2}
}

func (fake *FakeRepositoryRepository) MarkAsCloned(arg1 string, arg2 string, arg3 string) error {
	fake.markAsClonedMutex.Lock()
	ret, specificReturn := fake.markAsClonedReturnsOnCall[len(fake.markAsClonedArgsForCall)]
	fake.markAsClonedArgsForCall = append(fake.markAsClonedArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("MarkAsCloned", []interface{}{arg1, arg2, arg3})
	fake.markAsClonedMutex.Unlock()
	if fake.MarkAsClonedStub != nil {
		return fake.MarkAsClonedStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.markAsClonedReturns.result1
}

func (fake *FakeRepositoryRepository) MarkAsClonedCallCount() int {
	fake.markAsClonedMutex.RLock()
	defer fake.markAsClonedMutex.RUnlock()
	return len(fake.markAsClonedArgsForCall)
}

func (fake *FakeRepositoryRepository) MarkAsClonedArgsForCall(i int) (string, string, string) {
	fake.markAsClonedMutex.RLock()
	defer fake.markAsClonedMutex.RUnlock()
	return fake.markAsClonedArgsForCall[i].arg1, fake.markAsClonedArgsForCall[i].arg2, fake.markAsClonedArgsForCall[i].arg3
}

func (fake *FakeRepositoryRepository) MarkAsClonedReturns(result1 error) {
	fake.MarkAsClonedStub = nil
	fake.markAsClonedReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepositoryRepository) MarkAsClonedReturnsOnCall(i int, result1 error) {
	fake.MarkAsClonedStub = nil
	if fake.markAsClonedReturnsOnCall == nil {
		fake.markAsClonedReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.markAsClonedReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepositoryRepository) Reenable(arg1 string, arg2 string) error {
	fake.reenableMutex.Lock()
	ret, specificReturn := fake.reenableReturnsOnCall[len(fake.reenableArgsForCall)]
	fake.reenableArgsForCall = append(fake.reenableArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("Reenable", []interface{}{arg1, arg2})
	fake.reenableMutex.Unlock()
	if fake.ReenableStub != nil {
		return fake.ReenableStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.reenableReturns.result1
}

func (fake *FakeRepositoryRepository) ReenableCallCount() int {
	fake.reenableMutex.RLock()
	defer fake.reenableMutex.RUnlock()
	return len(fake.reenableArgsForCall)
}

func (fake *FakeRepositoryRepository) ReenableArgsForCall(i int) (string, string) {
	fake.reenableMutex.RLock()
	defer fake.reenableMutex.RUnlock()
	return fake.reenableArgsForCall[i].arg1, fake.reenableArgsForCall[i].arg2
}

func (fake *FakeRepositoryRepository) ReenableReturns(result1 error) {
	fake.ReenableStub = nil
	fake.reenableReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepositoryRepository) ReenableReturnsOnCall(i int, result1 error) {
	fake.ReenableStub = nil
	if fake.reenableReturnsOnCall == nil {
		fake.reenableReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.reenableReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepositoryRepository) RegisterFailedFetch(arg1 lager.Logger, arg2 *db.Repository) error {
	fake.registerFailedFetchMutex.Lock()
	ret, specificReturn := fake.registerFailedFetchReturnsOnCall[len(fake.registerFailedFetchArgsForCall)]
	fake.registerFailedFetchArgsForCall = append(fake.registerFailedFetchArgsForCall, struct {
		arg1 lager.Logger
		arg2 *db.Repository
	}{arg1, arg2})
	fake.recordInvocation("RegisterFailedFetch", []interface{}{arg1, arg2})
	fake.registerFailedFetchMutex.Unlock()
	if fake.RegisterFailedFetchStub != nil {
		return fake.RegisterFailedFetchStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.registerFailedFetchReturns.result1
}

func (fake *FakeRepositoryRepository) RegisterFailedFetchCallCount() int {
	fake.registerFailedFetchMutex.RLock()
	defer fake.registerFailedFetchMutex.RUnlock()
	return len(fake.registerFailedFetchArgsForCall)
}

func (fake *FakeRepositoryRepository) RegisterFailedFetchArgsForCall(i int) (lager.Logger, *db.Repository) {
	fake.registerFailedFetchMutex.RLock()
	defer fake.registerFailedFetchMutex.RUnlock()
	return fake.registerFailedFetchArgsForCall[i].arg1, fake.registerFailedFetchArgsForCall[i].arg2
}

func (fake *FakeRepositoryRepository) RegisterFailedFetchReturns(result1 error) {
	fake.RegisterFailedFetchStub = nil
	fake.registerFailedFetchReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepositoryRepository) RegisterFailedFetchReturnsOnCall(i int, result1 error) {
	fake.RegisterFailedFetchStub = nil
	if fake.registerFailedFetchReturnsOnCall == nil {
		fake.registerFailedFetchReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.registerFailedFetchReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepositoryRepository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.findMutex.RLock()
	defer fake.findMutex.RUnlock()
	fake.mustFindMutex.RLock()
	defer fake.mustFindMutex.RUnlock()
	fake.allMutex.RLock()
	defer fake.allMutex.RUnlock()
	fake.activeMutex.RLock()
	defer fake.activeMutex.RUnlock()
	fake.allForOrganizationMutex.RLock()
	defer fake.allForOrganizationMutex.RUnlock()
	fake.notScannedWithVersionMutex.RLock()
	defer fake.notScannedWithVersionMutex.RUnlock()
	fake.markAsClonedMutex.RLock()
	defer fake.markAsClonedMutex.RUnlock()
	fake.reenableMutex.RLock()
	defer fake.reenableMutex.RUnlock()
	fake.registerFailedFetchMutex.RLock()
	defer fake.registerFailedFetchMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeRepositoryRepository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.RepositoryRepository = new(FakeRepositoryRepository)
