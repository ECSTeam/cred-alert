// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	"cred-alert/db"
	"sync"
)

type FakeBranchRepository struct {
	GetBranchesStub        func(repository db.Repository) ([]db.Branch, error)
	getBranchesMutex       sync.RWMutex
	getBranchesArgsForCall []struct {
		repository db.Repository
	}
	getBranchesReturns struct {
		result1 []db.Branch
		result2 error
	}
	getBranchesReturnsOnCall map[int]struct {
		result1 []db.Branch
		result2 error
	}
	UpdateBranchesStub        func(repository db.Repository, branches []db.Branch) error
	updateBranchesMutex       sync.RWMutex
	updateBranchesArgsForCall []struct {
		repository db.Repository
		branches   []db.Branch
	}
	updateBranchesReturns struct {
		result1 error
	}
	updateBranchesReturnsOnCall map[int]struct {
		result1 error
	}
	GetCredentialCountByOwnerStub        func() ([]db.OwnerCredentialCount, error)
	getCredentialCountByOwnerMutex       sync.RWMutex
	getCredentialCountByOwnerArgsForCall []struct{}
	getCredentialCountByOwnerReturns     struct {
		result1 []db.OwnerCredentialCount
		result2 error
	}
	getCredentialCountByOwnerReturnsOnCall map[int]struct {
		result1 []db.OwnerCredentialCount
		result2 error
	}
	GetCredentialCountForOwnerStub        func(owner string) ([]db.RepositoryCredentialCount, error)
	getCredentialCountForOwnerMutex       sync.RWMutex
	getCredentialCountForOwnerArgsForCall []struct {
		owner string
	}
	getCredentialCountForOwnerReturns struct {
		result1 []db.RepositoryCredentialCount
		result2 error
	}
	getCredentialCountForOwnerReturnsOnCall map[int]struct {
		result1 []db.RepositoryCredentialCount
		result2 error
	}
	GetCredentialCountForRepoStub        func(owner string, repo string) ([]db.BranchCredentialCount, error)
	getCredentialCountForRepoMutex       sync.RWMutex
	getCredentialCountForRepoArgsForCall []struct {
		owner string
		repo  string
	}
	getCredentialCountForRepoReturns struct {
		result1 []db.BranchCredentialCount
		result2 error
	}
	getCredentialCountForRepoReturnsOnCall map[int]struct {
		result1 []db.BranchCredentialCount
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeBranchRepository) GetBranches(repository db.Repository) ([]db.Branch, error) {
	fake.getBranchesMutex.Lock()
	ret, specificReturn := fake.getBranchesReturnsOnCall[len(fake.getBranchesArgsForCall)]
	fake.getBranchesArgsForCall = append(fake.getBranchesArgsForCall, struct {
		repository db.Repository
	}{repository})
	fake.recordInvocation("GetBranches", []interface{}{repository})
	fake.getBranchesMutex.Unlock()
	if fake.GetBranchesStub != nil {
		return fake.GetBranchesStub(repository)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getBranchesReturns.result1, fake.getBranchesReturns.result2
}

func (fake *FakeBranchRepository) GetBranchesCallCount() int {
	fake.getBranchesMutex.RLock()
	defer fake.getBranchesMutex.RUnlock()
	return len(fake.getBranchesArgsForCall)
}

func (fake *FakeBranchRepository) GetBranchesArgsForCall(i int) db.Repository {
	fake.getBranchesMutex.RLock()
	defer fake.getBranchesMutex.RUnlock()
	return fake.getBranchesArgsForCall[i].repository
}

func (fake *FakeBranchRepository) GetBranchesReturns(result1 []db.Branch, result2 error) {
	fake.GetBranchesStub = nil
	fake.getBranchesReturns = struct {
		result1 []db.Branch
		result2 error
	}{result1, result2}
}

func (fake *FakeBranchRepository) GetBranchesReturnsOnCall(i int, result1 []db.Branch, result2 error) {
	fake.GetBranchesStub = nil
	if fake.getBranchesReturnsOnCall == nil {
		fake.getBranchesReturnsOnCall = make(map[int]struct {
			result1 []db.Branch
			result2 error
		})
	}
	fake.getBranchesReturnsOnCall[i] = struct {
		result1 []db.Branch
		result2 error
	}{result1, result2}
}

func (fake *FakeBranchRepository) UpdateBranches(repository db.Repository, branches []db.Branch) error {
	var branchesCopy []db.Branch
	if branches != nil {
		branchesCopy = make([]db.Branch, len(branches))
		copy(branchesCopy, branches)
	}
	fake.updateBranchesMutex.Lock()
	ret, specificReturn := fake.updateBranchesReturnsOnCall[len(fake.updateBranchesArgsForCall)]
	fake.updateBranchesArgsForCall = append(fake.updateBranchesArgsForCall, struct {
		repository db.Repository
		branches   []db.Branch
	}{repository, branchesCopy})
	fake.recordInvocation("UpdateBranches", []interface{}{repository, branchesCopy})
	fake.updateBranchesMutex.Unlock()
	if fake.UpdateBranchesStub != nil {
		return fake.UpdateBranchesStub(repository, branches)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.updateBranchesReturns.result1
}

func (fake *FakeBranchRepository) UpdateBranchesCallCount() int {
	fake.updateBranchesMutex.RLock()
	defer fake.updateBranchesMutex.RUnlock()
	return len(fake.updateBranchesArgsForCall)
}

func (fake *FakeBranchRepository) UpdateBranchesArgsForCall(i int) (db.Repository, []db.Branch) {
	fake.updateBranchesMutex.RLock()
	defer fake.updateBranchesMutex.RUnlock()
	return fake.updateBranchesArgsForCall[i].repository, fake.updateBranchesArgsForCall[i].branches
}

func (fake *FakeBranchRepository) UpdateBranchesReturns(result1 error) {
	fake.UpdateBranchesStub = nil
	fake.updateBranchesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBranchRepository) UpdateBranchesReturnsOnCall(i int, result1 error) {
	fake.UpdateBranchesStub = nil
	if fake.updateBranchesReturnsOnCall == nil {
		fake.updateBranchesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateBranchesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBranchRepository) GetCredentialCountByOwner() ([]db.OwnerCredentialCount, error) {
	fake.getCredentialCountByOwnerMutex.Lock()
	ret, specificReturn := fake.getCredentialCountByOwnerReturnsOnCall[len(fake.getCredentialCountByOwnerArgsForCall)]
	fake.getCredentialCountByOwnerArgsForCall = append(fake.getCredentialCountByOwnerArgsForCall, struct{}{})
	fake.recordInvocation("GetCredentialCountByOwner", []interface{}{})
	fake.getCredentialCountByOwnerMutex.Unlock()
	if fake.GetCredentialCountByOwnerStub != nil {
		return fake.GetCredentialCountByOwnerStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getCredentialCountByOwnerReturns.result1, fake.getCredentialCountByOwnerReturns.result2
}

func (fake *FakeBranchRepository) GetCredentialCountByOwnerCallCount() int {
	fake.getCredentialCountByOwnerMutex.RLock()
	defer fake.getCredentialCountByOwnerMutex.RUnlock()
	return len(fake.getCredentialCountByOwnerArgsForCall)
}

func (fake *FakeBranchRepository) GetCredentialCountByOwnerReturns(result1 []db.OwnerCredentialCount, result2 error) {
	fake.GetCredentialCountByOwnerStub = nil
	fake.getCredentialCountByOwnerReturns = struct {
		result1 []db.OwnerCredentialCount
		result2 error
	}{result1, result2}
}

func (fake *FakeBranchRepository) GetCredentialCountByOwnerReturnsOnCall(i int, result1 []db.OwnerCredentialCount, result2 error) {
	fake.GetCredentialCountByOwnerStub = nil
	if fake.getCredentialCountByOwnerReturnsOnCall == nil {
		fake.getCredentialCountByOwnerReturnsOnCall = make(map[int]struct {
			result1 []db.OwnerCredentialCount
			result2 error
		})
	}
	fake.getCredentialCountByOwnerReturnsOnCall[i] = struct {
		result1 []db.OwnerCredentialCount
		result2 error
	}{result1, result2}
}

func (fake *FakeBranchRepository) GetCredentialCountForOwner(owner string) ([]db.RepositoryCredentialCount, error) {
	fake.getCredentialCountForOwnerMutex.Lock()
	ret, specificReturn := fake.getCredentialCountForOwnerReturnsOnCall[len(fake.getCredentialCountForOwnerArgsForCall)]
	fake.getCredentialCountForOwnerArgsForCall = append(fake.getCredentialCountForOwnerArgsForCall, struct {
		owner string
	}{owner})
	fake.recordInvocation("GetCredentialCountForOwner", []interface{}{owner})
	fake.getCredentialCountForOwnerMutex.Unlock()
	if fake.GetCredentialCountForOwnerStub != nil {
		return fake.GetCredentialCountForOwnerStub(owner)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getCredentialCountForOwnerReturns.result1, fake.getCredentialCountForOwnerReturns.result2
}

func (fake *FakeBranchRepository) GetCredentialCountForOwnerCallCount() int {
	fake.getCredentialCountForOwnerMutex.RLock()
	defer fake.getCredentialCountForOwnerMutex.RUnlock()
	return len(fake.getCredentialCountForOwnerArgsForCall)
}

func (fake *FakeBranchRepository) GetCredentialCountForOwnerArgsForCall(i int) string {
	fake.getCredentialCountForOwnerMutex.RLock()
	defer fake.getCredentialCountForOwnerMutex.RUnlock()
	return fake.getCredentialCountForOwnerArgsForCall[i].owner
}

func (fake *FakeBranchRepository) GetCredentialCountForOwnerReturns(result1 []db.RepositoryCredentialCount, result2 error) {
	fake.GetCredentialCountForOwnerStub = nil
	fake.getCredentialCountForOwnerReturns = struct {
		result1 []db.RepositoryCredentialCount
		result2 error
	}{result1, result2}
}

func (fake *FakeBranchRepository) GetCredentialCountForOwnerReturnsOnCall(i int, result1 []db.RepositoryCredentialCount, result2 error) {
	fake.GetCredentialCountForOwnerStub = nil
	if fake.getCredentialCountForOwnerReturnsOnCall == nil {
		fake.getCredentialCountForOwnerReturnsOnCall = make(map[int]struct {
			result1 []db.RepositoryCredentialCount
			result2 error
		})
	}
	fake.getCredentialCountForOwnerReturnsOnCall[i] = struct {
		result1 []db.RepositoryCredentialCount
		result2 error
	}{result1, result2}
}

func (fake *FakeBranchRepository) GetCredentialCountForRepo(owner string, repo string) ([]db.BranchCredentialCount, error) {
	fake.getCredentialCountForRepoMutex.Lock()
	ret, specificReturn := fake.getCredentialCountForRepoReturnsOnCall[len(fake.getCredentialCountForRepoArgsForCall)]
	fake.getCredentialCountForRepoArgsForCall = append(fake.getCredentialCountForRepoArgsForCall, struct {
		owner string
		repo  string
	}{owner, repo})
	fake.recordInvocation("GetCredentialCountForRepo", []interface{}{owner, repo})
	fake.getCredentialCountForRepoMutex.Unlock()
	if fake.GetCredentialCountForRepoStub != nil {
		return fake.GetCredentialCountForRepoStub(owner, repo)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getCredentialCountForRepoReturns.result1, fake.getCredentialCountForRepoReturns.result2
}

func (fake *FakeBranchRepository) GetCredentialCountForRepoCallCount() int {
	fake.getCredentialCountForRepoMutex.RLock()
	defer fake.getCredentialCountForRepoMutex.RUnlock()
	return len(fake.getCredentialCountForRepoArgsForCall)
}

func (fake *FakeBranchRepository) GetCredentialCountForRepoArgsForCall(i int) (string, string) {
	fake.getCredentialCountForRepoMutex.RLock()
	defer fake.getCredentialCountForRepoMutex.RUnlock()
	return fake.getCredentialCountForRepoArgsForCall[i].owner, fake.getCredentialCountForRepoArgsForCall[i].repo
}

func (fake *FakeBranchRepository) GetCredentialCountForRepoReturns(result1 []db.BranchCredentialCount, result2 error) {
	fake.GetCredentialCountForRepoStub = nil
	fake.getCredentialCountForRepoReturns = struct {
		result1 []db.BranchCredentialCount
		result2 error
	}{result1, result2}
}

func (fake *FakeBranchRepository) GetCredentialCountForRepoReturnsOnCall(i int, result1 []db.BranchCredentialCount, result2 error) {
	fake.GetCredentialCountForRepoStub = nil
	if fake.getCredentialCountForRepoReturnsOnCall == nil {
		fake.getCredentialCountForRepoReturnsOnCall = make(map[int]struct {
			result1 []db.BranchCredentialCount
			result2 error
		})
	}
	fake.getCredentialCountForRepoReturnsOnCall[i] = struct {
		result1 []db.BranchCredentialCount
		result2 error
	}{result1, result2}
}

func (fake *FakeBranchRepository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getBranchesMutex.RLock()
	defer fake.getBranchesMutex.RUnlock()
	fake.updateBranchesMutex.RLock()
	defer fake.updateBranchesMutex.RUnlock()
	fake.getCredentialCountByOwnerMutex.RLock()
	defer fake.getCredentialCountByOwnerMutex.RUnlock()
	fake.getCredentialCountForOwnerMutex.RLock()
	defer fake.getCredentialCountForOwnerMutex.RUnlock()
	fake.getCredentialCountForRepoMutex.RLock()
	defer fake.getCredentialCountForRepoMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeBranchRepository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.BranchRepository = new(FakeBranchRepository)
