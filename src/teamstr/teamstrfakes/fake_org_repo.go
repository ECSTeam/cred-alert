// This file was generated by counterfeiter
package teamstrfakes

import (
	"context"
	"sync"
	"teamstr"

	"github.com/google/go-github/github"
)

type FakeOrgRepo struct {
	AddTeamRepoStub        func(ctx context.Context, team int, owner string, repo string, opt *github.OrganizationAddTeamRepoOptions) (*github.Response, error)
	addTeamRepoMutex       sync.RWMutex
	addTeamRepoArgsForCall []struct {
		ctx   context.Context
		team  int
		owner string
		repo  string
		opt   *github.OrganizationAddTeamRepoOptions
	}
	addTeamRepoReturns struct {
		result1 *github.Response
		result2 error
	}
	ListTeamReposStub        func(ctx context.Context, team int, opt *github.ListOptions) ([]*github.Repository, *github.Response, error)
	listTeamReposMutex       sync.RWMutex
	listTeamReposArgsForCall []struct {
		ctx  context.Context
		team int
		opt  *github.ListOptions
	}
	listTeamReposReturns struct {
		result1 []*github.Repository
		result2 *github.Response
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeOrgRepo) AddTeamRepo(ctx context.Context, team int, owner string, repo string, opt *github.OrganizationAddTeamRepoOptions) (*github.Response, error) {
	fake.addTeamRepoMutex.Lock()
	fake.addTeamRepoArgsForCall = append(fake.addTeamRepoArgsForCall, struct {
		ctx   context.Context
		team  int
		owner string
		repo  string
		opt   *github.OrganizationAddTeamRepoOptions
	}{ctx, team, owner, repo, opt})
	fake.recordInvocation("AddTeamRepo", []interface{}{ctx, team, owner, repo, opt})
	fake.addTeamRepoMutex.Unlock()
	if fake.AddTeamRepoStub != nil {
		return fake.AddTeamRepoStub(ctx, team, owner, repo, opt)
	}
	return fake.addTeamRepoReturns.result1, fake.addTeamRepoReturns.result2
}

func (fake *FakeOrgRepo) AddTeamRepoCallCount() int {
	fake.addTeamRepoMutex.RLock()
	defer fake.addTeamRepoMutex.RUnlock()
	return len(fake.addTeamRepoArgsForCall)
}

func (fake *FakeOrgRepo) AddTeamRepoArgsForCall(i int) (context.Context, int, string, string, *github.OrganizationAddTeamRepoOptions) {
	fake.addTeamRepoMutex.RLock()
	defer fake.addTeamRepoMutex.RUnlock()
	return fake.addTeamRepoArgsForCall[i].ctx, fake.addTeamRepoArgsForCall[i].team, fake.addTeamRepoArgsForCall[i].owner, fake.addTeamRepoArgsForCall[i].repo, fake.addTeamRepoArgsForCall[i].opt
}

func (fake *FakeOrgRepo) AddTeamRepoReturns(result1 *github.Response, result2 error) {
	fake.AddTeamRepoStub = nil
	fake.addTeamRepoReturns = struct {
		result1 *github.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeOrgRepo) ListTeamRepos(ctx context.Context, team int, opt *github.ListOptions) ([]*github.Repository, *github.Response, error) {
	fake.listTeamReposMutex.Lock()
	fake.listTeamReposArgsForCall = append(fake.listTeamReposArgsForCall, struct {
		ctx  context.Context
		team int
		opt  *github.ListOptions
	}{ctx, team, opt})
	fake.recordInvocation("ListTeamRepos", []interface{}{ctx, team, opt})
	fake.listTeamReposMutex.Unlock()
	if fake.ListTeamReposStub != nil {
		return fake.ListTeamReposStub(ctx, team, opt)
	}
	return fake.listTeamReposReturns.result1, fake.listTeamReposReturns.result2, fake.listTeamReposReturns.result3
}

func (fake *FakeOrgRepo) ListTeamReposCallCount() int {
	fake.listTeamReposMutex.RLock()
	defer fake.listTeamReposMutex.RUnlock()
	return len(fake.listTeamReposArgsForCall)
}

func (fake *FakeOrgRepo) ListTeamReposArgsForCall(i int) (context.Context, int, *github.ListOptions) {
	fake.listTeamReposMutex.RLock()
	defer fake.listTeamReposMutex.RUnlock()
	return fake.listTeamReposArgsForCall[i].ctx, fake.listTeamReposArgsForCall[i].team, fake.listTeamReposArgsForCall[i].opt
}

func (fake *FakeOrgRepo) ListTeamReposReturns(result1 []*github.Repository, result2 *github.Response, result3 error) {
	fake.ListTeamReposStub = nil
	fake.listTeamReposReturns = struct {
		result1 []*github.Repository
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeOrgRepo) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addTeamRepoMutex.RLock()
	defer fake.addTeamRepoMutex.RUnlock()
	fake.listTeamReposMutex.RLock()
	defer fake.listTeamReposMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeOrgRepo) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ teamstr.OrgRepo = new(FakeOrgRepo)
